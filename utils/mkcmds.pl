#!/usr/bin/perl 
# perl version of the old mkcmds.sh script. Runs faster by simply not running
# a bazillion child processes.

use strict; # Please ma'am may I have another?
use warnings;
use File::Compare;
use File::Copy;
use feature qw/say/;

use subs qw/make_switches make_cmds make_funs/;
use subs qw/maybemove temp_header temp_source scan_files_for_pattern/;

# Main loop, dispatch for each command line argument.
foreach my $command (@ARGV) {
    if ($command eq "switches") {
        make_switches;
    } elsif ($command eq "commands") {
        make_cmds;
    } elsif ($command eq "functions") {
        make_funs;
    } elsif ($command eq "all") {
        make_switches;
        make_cmds;
        make_funs;
    } else {
        warn "Unknown option '${command}'\n";
    }
}

# Return name of a temp file in hdrs/
sub temp_header {
    return "hdrs/temp.$$.h";
}

# Return name of a temp file in src/
sub temp_source {
    return "src/temp.$$.c";
}

# maybemove(file1, file2) copies file1 to file 2 if they are different,
# otherwise just deletes file1 and leaves file2 unchanged.
sub maybemove {
    my ($from, $to) = @_;

    if (compare $from, $to) {
        if (move $from, $to) {
            say "File ${to} updated.";
        } else {
            warn "Couldn't rename ${from} to ${to}: $!\n";
        }
    } else {
        say "File ${to} unchanged.";
        unlink $from;
    }
}

# scan_files_for_pattern(glob-pattern, re) searches all files matching
# glob-pattern for lines matching re, and returns a sorted list of
# $1's for each matching line.
sub scan_files_for_pattern {
    my ($filepattern, $re) = @_;
    my @idents;

    foreach my $file (glob $filepattern) {
        open my $FILE, "<", $file
            or die "Cannot open ${file} for reading: $!\n";
        while (<$FILE>) {
            s/\s+$//; # Some versions of perl for windows don't handle line ending conversion properly and chomp leaves a \r at the end. Sigh.
            push @idents, $1 if m/$re/;
        }
        close $FILE;
    }
    return sort @idents;
}


END {
    # Make sure temp files get deleted.
    my @files = (temp_header(), temp_source());
    foreach my $file (@files) {
        unlink $file if -f $file;
    }
}

sub make_switches {
    say "Rebuilding command switch file and header.";

    my $temphdr = temp_header;
    my $tempsrc = temp_source;

    my @switches = scan_files_for_pattern "src/SWITCHES", qr/^(.+)/;

    open my $HDR, ">", $temphdr or
        die "Unable to open $temphdr for writing: $!\n";
    open my $SRC, ">", $tempsrc or
        die "Unable to open $tempsrc for writing: $!\n";

    print $HDR <<EOH;
/* AUTOGENERATED FILE. DO NOT EDIT! */
#ifndef SWITCHES_H
#define SWITCHES_H
EOH

    my $nswitches = @switches;
    my $maxswitch = $nswitches;
    $nswitches += 1;

    print $SRC <<EOS;
/* AUTOGENERATED FILE. DO NOT EDIT! */
static const int max_switch = ${maxswitch};
SWITCH_VALUE switch_list[${nswitches}] = {
EOS

    my $n = 1;
    foreach my $switch (@switches) {
        say $HDR "#define SWITCH_${switch} ${n}";
        say $SRC "  {\"${switch}\", SWITCH_${switch}, 0},";
        $n++;
    }

    print $SRC <<EOS;
  {NULL, 0, 0}
};
EOS
    close $SRC;

    say $HDR "#endif                          /* SWITCHES_H */";
    close $HDR;

    maybemove $temphdr, "hdrs/switches.h";
    maybemove $tempsrc, "src/switchinc.c";
}

# I really should combine this and make_funs into one function that does
# the work with specific files/regexps/defines passed as arguments

sub make_cmds {
    say "Rebuilding command prototype header.";

    my $tempfile = temp_header;

    my @commands =
        scan_files_for_pattern "src/*.c", qr/^\s*COMMAND\(([^\)]+)\)/;

    open my $HDR, ">", $tempfile
        or die "Can't open ${tempfile} for writing: $!\n";


    print $HDR <<EOH;
/* AUTOGENERATED FILE. DO NOT EDIT! */
#ifndef CMDS_H
#define CMDS_H
#include "command.h"
EOH

    foreach my $command (@commands) {
        say $HDR "COMMAND_PROTO(${command});";
    }

    say $HDR "#endif /* CMDS_H */";
    close $HDR;

    maybemove $tempfile, "hdrs/cmds.h";

}

sub make_funs {
    print "Rebuilding function prototype header.\n";

    my $tempfile = temp_header;
    my @functions =
        scan_files_for_pattern "src/*.c", qr/^\s*FUNCTION\(([^\)]+)\)/;

    open my $HDR, ">", $tempfile
        or die "Can't open ${tempfile} for writing: $!\n";

    print $HDR <<EOH;
/* AUTOGENERATED FILE. DO NOT EDIT! */
#ifndef FUNS_H
#define FUNS_H
EOH

    foreach my $function (@functions) {
        say $HDR "FUNCTION_PROTO(${function});";
    }

    say $HDR "#endif /* FUNS_H */";
    close $HDR;

    maybemove $tempfile, "hdrs/funs.h";
}

